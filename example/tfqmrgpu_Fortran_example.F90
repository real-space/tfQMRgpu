! include "tfqmrgpu_Fortran_module.F90"

#define DEBUG

  program tfqmrgpu_run_example
  !! test driver to run the Fortran example delivered with the tfqmrgpu library
  use tfqmrgpu, only: tfqmrgpu_bsrsv_complete
  implicit none

    integer :: iarg, length, status, it
    character(len=96) :: arg
    real(kind=8) :: maxdev(3)

    do iarg = 0, command_argument_count()
        call get_command_argument(iarg, arg, length, status)
        write(*,*) iarg, length, status, trim(arg)
    enddo ! iarg

    !! test 1) in this example we have only one block
    maxdev(1) = test(32, 32, rowPtr=[1, 2], colInd=[1])

    !! test 2) in this example use a full matrix as the reference which is generated by matmul
    !! and which does not treat the sparsity constraint onto Y exactly like the solver
    !!   colInd =
    !!   1 2 3 4
    !!   1 2 3 4
    !!   1 2 3 4
    !!   1 2 3 4
    !!   rowPtr = 1 +4 +4 +4 +4
    maxdev(2) = test(16, 16, rowPtr=[1, 5, 9, 13, 17], &
             colInd=[1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4])

    !! test 3) in this example we only check if it runs through for a
    !! not fully occupied sparsity pattern: 4x4 blocks
    !!   colInd =
    !!   1 2
    !!   1 2 3
    !!     2 3 4
    !!       3 4
    !!   rowPtr = 1 +2 +3 +3 +2
    maxdev(3) = test(4, 4, rowPtr=[1, 3, 6, 9, 11], &
             colInd=[1, 2, 1, 2, 3, 2, 3, 4, 3, 4])

    write(*,"(a,9es9.1)") " maxdev(:)=",maxdev(:)

  contains

  real(kind=8) function test(ldA, ldX, rowPtr, colInd) result(maxdev)
    integer(kind=4), intent(in) :: ldA, ldX ! block dimension
    integer(kind=4), intent(in) :: rowPtr(:)
    integer(kind=4), intent(in) :: colInd(:)

    ! local variables
    integer(kind=4) :: mb, nnzb, M, N
    complex(kind=8), allocatable :: Amat(:,:,:)   ! Amat(ldA,ldA,nnzb) ! list of blocks of A, later used for B^T and X
    real(kind=8),    allocatable :: Amar(:,:,:,:) ! Amar(ldA,ldA,nnzb,2) ! temp as random_number() is only defined for reals

#ifdef  DEBUG
    complex(kind=8), allocatable, dimension(:,:) :: Afull, Xfull, Bfull, Yfull
#endif

    integer(kind=4) :: iterations ! max number of iterations allowed
    real(kind=8) :: residual ! threshold for the requested residual
    integer, parameter :: o = 6 ! unit to log to
    integer(kind=4) :: ierr

    if (ldX /= ldA) stop 'rectangular feature not yet implemented in tfqmrgpu_bsrsv_complete'

    iterations = 999
    residual = 1.d-9
    ierr = 1 ! 1: do also sanity checks

    mb = size(rowPtr) - 1
    nnzb = size(colInd)
    write(*,*) ! empty line
    write(*,"(9(a,i0))") "tfqmrgpu_Fortran_example BS=",ldA," m=",mb," nnzb=",nnzb
    if (nnzb > mb*mb) stop "tfqmrgpu_Fortran_example too many blocks!"

    !!
    !! Test symbols:
    !!      mb      number of block rows in the problem
    !!      nnzb    number of non-zero blocks
    !!      rowPtr  index starts of a row in the BSR formar
    !!      CSR     compressed sparse row format
    !!      BSR     block-compressed sparse row format
    !!              similar to CSR but with block matrices instead of scalars
    !!      indCol  column indices in the BSR format
    !!      ldA     leading dimension == blocksize
    !!      #full   dense matrix representation, # in {A,B,X,Y:=A*X}


    allocate( Amat(ldA,ldA,nnzb), Amar(ldA,ldA,nnzb,2) )
    call random_number(Amar) ! generate ldA*ldA*nnzb*2 pseudo-random doubles
    Amat = dcmplx(Amar(:,:,:,1), Amar(:,:,:,2)) ! interleave real and imaginary parts
    deallocate( Amar )

    M = mb*ldA
    N = mb*ldX
#ifdef  DEBUG
    allocate( Afull(M,M), Bfull(N,M), Xfull(N,M), Yfull(N,M) )
    call convert_bsr_to_full(Afull, rowPtr, colInd, Amat, 'n')
    call convert_bsr_to_full(Bfull, rowPtr, colInd, Amat, 't')
#endif

    !! solve A * X == B for X
    call tfqmrgpu_bsrsv_complete(mb, ldA, &
        rowPtr, colInd, Amat, 'n', & !! A (in)
        rowPtr, colInd, Amat, 'n', & !! X (out)
        rowPtr, colInd, Amat, 't', & !! B (in)
        iterations, residual, o, ierr)

   maxdev = -1

#ifdef  DEBUG
    call write_bsr_to_file("Xmat", "X", rowPtr, colInd, Amat, 'n')
    call convert_bsr_to_full(Xfull, rowPtr, colInd, Amat, 'n')
    Yfull = matmul(Xfull, Afull) ! works if block transpositions are A:'n', B:'t', X:'n'
    maxdev = maxval(abs(Yfull - Bfull))
    write(*, '(a,es9.1)') " Max. deviation |A*X - B| =", maxdev
    if (maxdev > 1e-8) then
      write(23,*) "# Yfull" ; write(23,'(2f10.6)') Yfull
      write(13,*) "# Bfull" ; write(13,'(2f10.6)') Bfull
      write(*,*) "Warning! Deviations are larger the 10^-8, B and A*X are written to fort.13 and fort.23, respectively."
    endif
    deallocate( Afull, Bfull, Xfull, Yfull )
#endif
    deallocate( Amat )

  endfunction ! test

#ifdef  DEBUG
!+debug

    subroutine convert_bsr_to_full(full, rowPtr, colInd, mat, trans)
      complex(kind=8), intent(out) :: full(:,:) ! mat(bd*nrow+,bd*nrow)
      integer(kind=4), intent(in) :: rowPtr(:) ! assume rowPtr(nrow+1)
      integer(kind=4), intent(in) :: colInd(:) ! assume colInd(nnzb)
      complex(kind=8), intent(in) :: mat(:,:,:) ! mat(bd+,bd,nnzb)
      character, intent(in) :: trans ! block transposition

      integer :: irow, jcol, ib, jb, inzb, bd, nrow, nnzb ! sparse matrix variables
      integer :: ir, jc ! global row and column indices into matrix full(jc,ir)

      bd = size(mat, 2) ! block dimension
      if (bd > size(mat, 1)) then
          write(*,*) "convert_bsr_to_full: ERROR: ld=",size(mat, 1)," < bd=",bd
          return ! leading dimension must not be smaller than the block dimension
      endif

      nrow = size(rowPtr) - 1 ! number of rows
      nnzb = size(colInd) ! number of non-zero blocks

      full(:,:) = 0 ! clear
      do irow = 1, nrow ! block row index
        do inzb = rowPtr(irow), rowPtr(irow+1)-1
          jcol = colInd(inzb) ! block column index
          !======================================================
          do ib = 1, bd      ! row index of the block (irow,jcol)
            ir = (irow - 1)*bd + ib ! global row index
            do jb = 1, bd ! column index of the block (irow,jcol)
              jc = (jcol - 1)*bd + jb ! global column index
              if ('n' == trans) then
                full(jc,ir) = mat(jb,ib,inzb)
              else  ! transpose
                full(jc,ir) = mat(ib,jb,inzb) ! transposed
              endif ! transpose
            enddo ! jb
          enddo ! ib
          !======================================================
        enddo ! inzb
      enddo ! irow

    endsubroutine ! convert_bsr_to_full

    subroutine write_bsr_to_file(filename, comment, rowPtr, colInd, mat, trans)
      character(len=*), intent(in) :: filename, comment
      integer(kind=4), intent(in) :: rowPtr(:) ! assume rowPtr(nrow+1)
      integer(kind=4), intent(in) :: colInd(:) ! assume colInd(nnzb)
      complex(kind=8), intent(in) :: mat(:,:,:) ! mat(bd+,bd,nnzb)
      character, intent(in) :: trans ! block transposition

      integer :: irow, jcol, ib, jb, inzb, b1, b2, nrow, nnzb ! sparse matrix variables
      integer :: u, ios
      character(len=*), parameter :: frmt = "(2f12.6)" ! "(2es24.16)"

      b1 = size(mat, 1)
      b2 = size(mat, 2) ! block dimension

      nrow = size(rowPtr) - 1 ! number of rows
      nnzb = size(colInd) ! number of non-zero blocks

      u = 642
      open(unit=u, file=filename, action="write", status="unknown", iostat=ios)
      if (0 /= ios) return ! cannot write the file

      write(u, fmt="(9a)", iostat=ios) "# block-sparse row format: ",trim(comment)
      do irow = 1, nrow ! block row index
        write(u, fmt="(/,9(a,i0))", iostat=ios) "# row ",irow," has ",rowPtr(irow+1) - 1 - rowPtr(irow)," elements"
        do inzb = rowPtr(irow), rowPtr(irow+1)-1
          jcol = colInd(inzb) ! block column index
          write(u, fmt="(/,a,9(' ',i0))", iostat=ios) "# block i j  ",irow,jcol
          if ('n' == trans) then
            do ib = 1, b2
              do jb = 1, b1
                write(u, frmt, iostat=ios) mat(jb,ib,inzb) ! non-transposed
              enddo ! jb
            enddo ! ib
          else  ! transpose
            do ib = 1, b1
              do jb = 1, b2
                write(u, frmt, iostat=ios) mat(ib,jb,inzb) ! transposed
              enddo ! jb
            enddo ! ib
          endif ! transpose
        enddo ! inzb
      enddo ! irow
      close(unit=u, iostat=ios)

    endsubroutine ! write_bsr_to_file

!-debug
#endif

  endprogram ! tfqmrgpu_run_example
